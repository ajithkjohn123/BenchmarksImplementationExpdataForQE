Contents
------------

This folder contains the benchmarks used in the experiments.

Folder boolean_combinations_of_lmcs/lindd/ contains the lindd benchmarks.

Folder boolean_combinations_of_lmcs/vhdl/ contains the vhdl benchmarks.

Folder conjunction_level_benchmarks/ contains benchmarks used 
for conjunction-level experiments to compare the performance 
of Project with alternative QE techniques based on bit-blasting 
and conversion to linear integer arithmetic. 

Folder vhdl_designs/ contains VHDL designs, property files etc. 
used for evaluating utility of QE algorithms in bounded model checking. 

Folder preprocessing_benchmarks/ contains benchmarks used 
for evaluating the utility of Layer1 and Layer2 as preprocessing 
steps before SMT solving.

Folder interpolation_benchmarks/ contains interpolation 
benchmarks used for comparison with Mathsat. 

Format of the lindd benchmarks
-----------------------------------------

These benchmarks are originally taken from the LinDD website 
http://sourceforge.net/projects/lindd/

Each benchmark is an SMTLIB file in the theory of integers,
representing a boolean combination of octagonal constraints 
with a set of variables to be eliminated. Octagonal constraints 
over integers are constraints of the form a.x + b.y <= k 
where x, y are integer variables, k is an integer constant, 
and a, b $\in$ {-1, 1}. 

For example,

(benchmark test
:extrafuns ((x Int))
:formula (exists (y Int) (and (<= (+ (* 1 x) (* (~1) y) ) 40 ) (not (<= (+ (* 1 x) (* (~1) y) ) 38) )))
)

represents \exists y. ( (x-y <= 40) and (x-y > 38) )  

We converted these benchmarks to Boolean combinations of LMCs 
by assuming the size of integer as 16-bits. 

Format of the vhdl benchmarks
------------------------------------------

Each benchmark is an SMTLIB file in the theory of bit-vectors,
representing a boolean combination of LMCs with a set of variables 
to be eliminated.

These benchmarks were obtained in the following manner. We took a set of 
word-level VHDL designs. We derived the symbolic transition relations of 
these VHDL designs. The vhdl benchmarks were obtained by quantifying out 
all the internal variables (i.e. neither input nor output of the top-level module) 
from these symbolic transition relations. Effectively this gives abstract 
transition relations of the designs. 

The set of variables to be eliminated is specified inside a 
specifier :exists(set of variables to be eliminated)

For example,

(benchmark test
:extrafuns ((a BitVec[4]))
:extrafuns ((b BitVec[4]))
:extrafuns ((c BitVec[4]))
:extrafuns ((d BitVec[4]))
:extrafuns ((e BitVec[4]))
:extrafuns ((f BitVec[4]))

:exists ( a  b )

:formula (if_then_else (= a b) (bvuge c d) (bvult e f))
)

represents \exists {a, b}. (if_then_else (a = b (mod 16))  (c >= d (mod 16)) (e < f (mod 16)) )  

Format of the conjunction_level_benchmarks 
-----------------------------------------------------

Each benchmark is an SMTLIB file in the theory of bit-vectors,
representing a conjunction of LMCs with a set of variables 
to be eliminated.

They are generated by applying QE_SMT on vhdl and lindd benchmarks, 
and then collecting the problem instances that arise at the 
conjunction-level. 

Format of these benchmarks is the same as the format of 
vhdl benchmarks. 

Details of vhdl_designs/
------------------------

Please see vhdl_designs/README


Format of the preprocessing_benchmarks 
-----------------------------------------------------

Each benchmark is an SMTLIB file in the theory of bit-vectors,
representing a conjunction of LMCs. 

They are generated by using a program "genrand" (see  
preprocessing_benchmarks/script_to_generate_benchmarks/genrand.c). 
genrand generates a random conjunction of LMCs with the given number of 
variables, number of LMIs, number of LMDs, and number of LMEs. 


Format of the interpolation_benchmarks 
-----------------------------------------------------

Each of these benchmarks is generated in the following way. 
First, we selected a subset of vhdl benchmarks. Note that each 
vhdl benchmark is a Boolean combination of LMCs $\varphi$ with 
a subset $X$ of variables in its support existentially quantified. 
Suppose $\exists X.\, \varphi$ is a vhdl benchmark. We computed 
$\exists X.\, \varphi$ using one of our algorithms for QE from 
Boolean combinations of LMCs. Let $\alpha$ be the quantifier-free 
version of $\exists X.\, \varphi$ thus computed, and let $Y$ be the 
set of variables in the support of $\alpha$. We then created a 
formula $\beta$ on variables in $Y\cup Z$, where $Z$ is a set of 
fresh variables. Let $\psi$ be the formula $\neg\alpha\wedge\beta$. 
Note that $\varphi$ and $\psi$ are mutually inconsistent. The final 
interpolation benchmark generated was $(\varphi, \psi)$. 

There are two versions of each benchmark. 
For benchmark_i, 
benchmark_i_for_qe.smt gives $\exists X.\, \varphi$ given to QE\_Combined
benchmark_i_for_mathsat.smt2 gives $(\varphi, \psi)$ given to Mathsat


Experimenting with the benchmarks
-----------------------------------------------

All the experiments reported in the paper on these benchmarks can be performed using the 
executables ../Implementations/Quantifier_Eliminator/Binary/Quantifier_Eliminator and
../Implementations/Bounded_Model_Checker/Core_Engine/Binary/Bounded_Model_Checker

Please look at ../Implementations/Quantifier_Eliminator/README and
../Implementations/Bounded_Model_Checker/README to see the details of executing 
these executables. 






