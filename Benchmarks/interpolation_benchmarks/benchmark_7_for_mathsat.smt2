;; MathSAT API call trace
;; generated on Mon Oct 10 14:21:33 2016
(set-option :global-decls true)
(set-option :config "verbosity=0")
(set-option :config "proof_generation=true")
(set-option :config "interpolation=true")
(set-option :config "model_generation=true")
(set-option :config "bool_model_generation=false")
(set-option :config "unsat_core_generation=0")
(set-option :config "random_seed=91648253")
(set-option :config "debug.dump_theory_lemmas=false")
(set-option :config "debug.solver_enabled=true")
(set-option :config "printer.bv_number_format=0")
(set-option :config "printer.fp_number_format=1")
(set-option :config "printer.defines_prefix=")
(set-option :config "preprocessor.toplevel_propagation=false")
(set-option :config "preprocessor.toplevel_propagation_limit=0")
(set-option :config "preprocessor.simplification=1")
(set-option :config "preprocessor.ite_minimization=false")
(set-option :config "preprocessor.ite_minimization_call_limit=150000")
(set-option :config "preprocessor.interpolation_ite_elimination=true")
(set-option :config "preprocessor.partial_nnf_conversion=false")
(set-option :config "dpll.restart_strategy=0")
(set-option :config "dpll.restart_initial=200")
(set-option :config "dpll.restart_geometric_factor=1.5")
(set-option :config "dpll.store_tlemmas=false")
(set-option :config "dpll.branching_random_frequency=0")
(set-option :config "dpll.branching_initial_phase=0")
(set-option :config "dpll.branching_cache_phase=2")
(set-option :config "dpll.branching_random_invalidate_phase_cache=false")
(set-option :config "dpll.branching_random_ignore_polarity=true")
(set-option :config "dpll.ghost_filtering=true")
(set-option :config "dpll.minimize_model=false")
(set-option :config "dpll.allsat_minimize_model=false")
(set-option :config "dpll.allsat_allow_duplicates=false")
(set-option :config "dpll.pop_btpoint_reset_var_order=false")
(set-option :config "dpll.glucose_var_activity=false")
(set-option :config "dpll.glucose_learnt_minimization=false")
(set-option :config "dpll.interpolation_mode=0")
(set-option :config "dpll.proof_simplification=false")
(set-option :config "dpll.preprocessor.mode=0")
(set-option :config "dpll.preprocessor.clause_size_limit=20")
(set-option :config "dpll.preprocessor.subsumption_size_limit=1000")
(set-option :config "dpll.preprocessor.elimination_grow_limit=0")
(set-option :config "dpll.preprocessor.elimination_phase=1")
(set-option :config "dpll.preprocessor.elimination_recent_vars_only=false")
(set-option :config "dpll.preprocessor.try_reelimination=true")
(set-option :config "theory.eq_propagation=true")
(set-option :config "theory.interface_eq_policy=2")
(set-option :config "theory.pairwise_interface_eq=true")
(set-option :config "theory.pure_literal_filtering=false")
(set-option :config "theory.euf.enabled=true")
(set-option :config "theory.euf.dyn_ack=0")
(set-option :config "theory.euf.dyn_ack_threshold=1")
(set-option :config "theory.euf.dyn_ack_limit=1000")
(set-option :config "theory.la.enabled=true")
(set-option :config "theory.la.split_rat_eq=false")
(set-option :config "theory.la.delay_alien=false")
(set-option :config "theory.la.pivoting_greedy_threshold=0")
(set-option :config "theory.la.lazy_expl_threshold=10")
(set-option :config "theory.la.interpolation_laz_use_floor=true")
(set-option :config "theory.la.pure_equality_filtering=true")
(set-option :config "theory.la.detect_euf_fragment=false")
(set-option :config "theory.la.deduction_enabled=true")
(set-option :config "theory.la.laz_equality_elimination=true")
(set-option :config "theory.la.laz_internal_branch_and_bound=true")
(set-option :config "theory.la.laz_internal_branch_and_bound_limit=1")
(set-option :config "theory.la.laz_cuts_from_proofs_mode=3")
(set-option :config "theory.la.laz_enabled=true")
(set-option :config "theory.la.laz_unit_cube_test=true")
(set-option :config "theory.la.interpolation_mode=0")
(set-option :config "theory.bv.enabled=true")
(set-option :config "theory.bv.div_by_zero_mode=0")
(set-option :config "theory.bv.delay_propagated_eqs=true")
(set-option :config "theory.bv.eager=false")
(set-option :config "theory.bv.bit_blast_mode=0")
(set-option :config "theory.bv.interpolation_mode=0")
(set-option :config "theory.bv.proof_simplification=false")
(set-option :config "theory.bv.lazydpll.restart_strategy=0")
(set-option :config "theory.bv.lazydpll.restart_initial=200")
(set-option :config "theory.bv.lazydpll.restart_geometric_factor=1.5")
(set-option :config "theory.bv.lazydpll.branching_random_frequency=0")
(set-option :config "theory.bv.lazydpll.branching_initial_phase=0")
(set-option :config "theory.bv.lazydpll.branching_cache_phase=2")
(set-option :config "theory.bv.lazydpll.branching_random_invalidate_phase_cache=false")
(set-option :config "theory.bv.lazydpll.branching_random_ignore_polarity=true")
(set-option :config "theory.bv.lazydpll.ghost_filtering=false")
(set-option :config "theory.bv.lazydpll.glucose_var_activity=false")
(set-option :config "theory.bv.lazydpll.glucose_learnt_minimization=false")
(set-option :config "theory.arr.enabled=true")
(set-option :config "theory.arr.mode=0")
(set-option :config "theory.arr.lazy_lemmas=true")
(set-option :config "theory.arr.check_on_approx=false")
(set-option :config "theory.arr.auto_wr_lemma=true")
(set-option :config "theory.arr.enable_wr_lemmas=true")
(set-option :config "theory.arr.enable_row_lemmas=true")
(set-option :config "theory.arr.enable_ext_lemmas=true")
(set-option :config "theory.arr.max_wr_lemmas=0")
(set-option :config "theory.arr.max_row_lemmas=0")
(set-option :config "theory.arr.max_ext_lemmas=0")
(set-option :config "theory.arr.enable_ext_polarity=true")
(set-option :config "theory.arr.enable_ext_arg=true")
(set-option :config "theory.arr.enable_witness=false")
(set-option :config "theory.arr.enable_nonlinear=true")
(set-option :config "theory.arr.enable_nonlinear_strat=false")
(set-option :config "theory.arr.enable_foreign=false")
(set-option :config "theory.arr.permanent_lemma_inst=false")
(set-option :config "theory.fp.enabled=true")
(set-option :config "theory.fp.minmax_zero_mode=1")
(set-option :config "theory.fp.mode=1")
(set-option :config "theory.fp.bv_combination_enabled=true")
(set-option :config "theory.fp.bit_blast_mode=2")
(set-option :config "theory.fp.dpll.restart_strategy=3")
(set-option :config "theory.fp.dpll.restart_initial=200")
(set-option :config "theory.fp.dpll.restart_geometric_factor=1.5")
(set-option :config "theory.fp.dpll.branching_random_frequency=0.01")
(set-option :config "theory.fp.dpll.branching_initial_phase=0")
(set-option :config "theory.fp.dpll.branching_cache_phase=1")
(set-option :config "theory.fp.dpll.branching_random_invalidate_phase_cache=false")
(set-option :config "theory.fp.dpll.branching_random_ignore_polarity=true")
(set-option :config "theory.fp.dpll.ghost_filtering=false")
(set-option :config "theory.fp.dpll.glucose_var_activity=true")
(set-option :config "theory.fp.dpll.glucose_learnt_minimization=true")
(set-option :config "theory.fp.acdcl_conflict_generalization=2")
(set-option :config "theory.fp.interpolation_mode=0")
(set-option :config "theory.fp.acdcl_single_propagation_limit=0")
(set-option :config "theory.fp.acdcl_single_generalization_limit=0")
(set-option :config "theory.fp.acdcl_generalization_fair=true")

(reset-assertions)
(declare-fun A_GRT_B_0 () (_ BitVec 1))
(declare-fun A_GRT_B_1 () (_ BitVec 1))
(declare-fun OPRNR_0 () (_ BitVec 1))
(declare-fun OPRNR_1 () (_ BitVec 1))
(declare-fun SUM_SUB__ADD_SUB__X_0 () (_ BitVec 22))
(declare-fun SUM_SUB__ADD_SUB__X_1 () (_ BitVec 22))
(declare-fun SUM_SUB__ADD_SUB__Y_0 () (_ BitVec 22))
(declare-fun SUM_SUB__ADD_SUB__Y_1 () (_ BitVec 22))
(declare-fun autoname_1 () (_ BitVec 22))
(declare-fun autoname_2 () (_ BitVec 22))
(declare-fun autoname_3 () (_ BitVec 22))
(declare-fun autoname_4 () (_ BitVec 22))
(declare-fun autoname_5 () (_ BitVec 22))
(declare-fun autoname_6 () (_ BitVec 22))
(declare-fun autoname_7 () (_ BitVec 22))
(declare-fun autoname_8 () (_ BitVec 1))
(declare-fun autoname_9 () (_ BitVec 1))
(declare-fun autoname_10 () (_ BitVec 1))
(declare-fun autoname_11 () (_ BitVec 1))
(define-fun $e1 () Bool (= A_GRT_B_1 #b1))
(define-fun $e2 () Bool (= A_GRT_B_1 #b0))
(define-fun $e3 () Bool (and (= autoname_6 autoname_6) (= autoname_7 autoname_7)))
(define-fun $e4 () Bool (bvult autoname_7 autoname_6))
(define-fun $e5 () Bool (= A_GRT_B_0 #b1))
(define-fun .f1 () Bool (ite (not $e3) (ite (not $e4) $e5 (= A_GRT_B_0 #b0)) (= A_GRT_B_0 A_GRT_B_0)))
(define-fun .f2 () Bool (= OPRNR_1 (bvadd autoname_8 autoname_9)))
(define-fun .f3 () Bool (ite (not (and (= autoname_3 autoname_6) (= autoname_2 autoname_7))) (ite (not (bvult autoname_2 autoname_3)) $e1 $e2) (ite (not $e3) (ite (not $e4) $e1 $e2) (= A_GRT_B_1 A_GRT_B_0))))
(define-fun .f4 () Bool (= autoname_4 autoname_5))
(define-fun .f5 () Bool (ite $e1 (= SUM_SUB__ADD_SUB__Y_1 autoname_3) (= SUM_SUB__ADD_SUB__Y_1 autoname_2)))
(define-fun .f6 () Bool (ite $e1 (= SUM_SUB__ADD_SUB__X_1 autoname_2) (= SUM_SUB__ADD_SUB__X_1 autoname_3)))
(define-fun .f7 () Bool (ite (= OPRNR_1 #b0) (= autoname_1 (bvadd SUM_SUB__ADD_SUB__X_1 SUM_SUB__ADD_SUB__Y_1)) (= autoname_1 (bvadd (bvmul #b0000000000000000000001 SUM_SUB__ADD_SUB__X_1) (bvmul #b1111111111111111111111 SUM_SUB__ADD_SUB__Y_1)))))
(define-fun .f8 () Bool (= OPRNR_0 (bvadd autoname_10 autoname_11)))
(define-fun .f9 () Bool (ite $e5 (= SUM_SUB__ADD_SUB__Y_0 autoname_6) (= SUM_SUB__ADD_SUB__Y_0 autoname_7)))
(define-fun .f10 () Bool (ite $e5 (= SUM_SUB__ADD_SUB__X_0 autoname_7) (= SUM_SUB__ADD_SUB__X_0 autoname_6)))

(assert (! .f1 :interpolation-group .g0))
(assert (! .f2 :interpolation-group .g0))
(assert (! .f3 :interpolation-group .g0))
(assert (! .f4 :interpolation-group .g0))
(assert (! .f5 :interpolation-group .g0))
(assert (! .f6 :interpolation-group .g0))
(assert (! .f7 :interpolation-group .g0))
(assert (! .f8 :interpolation-group .g0))
(assert (! .f9 :interpolation-group .g0))
(assert (! .f10 :interpolation-group .g0))

(define-fun $f1 () Bool (= (bvadd autoname_4 (bvmul #b1111111111111111111111 autoname_5)) #b0000000000000000000000))
(define-fun $f2 () Bool (= (bvadd autoname_2 (bvmul #b1111111111111111111111 autoname_7)) #b0000000000000000000000))
(define-fun $f3 () Bool (= (bvadd autoname_3 (bvmul #b1111111111111111111111 autoname_6)) #b0000000000000000000000))
(define-fun $f4 () Bool (and $f2 $f1 $f3))
(define-fun $f5 () (_ BitVec 1) (bvadd autoname_8 autoname_9))
(define-fun $f6 () (_ BitVec 22) (bvadd autoname_1 (bvmul #b1111111111111111111111 autoname_2)))
(define-fun $f7 () (_ BitVec 22) (bvmul #b1111111111111111111111 autoname_3))
(define-fun $f8 () Bool (and (= (bvadd $f6 $f7) #b0000000000000000000000) (= $f5 #b0)))
(define-fun $f9 () Bool (and $f1 (not (bvult autoname_2 autoname_3))))
(define-fun $f10 () Bool (and (not $f2) $f9))
(define-fun $f11 () Bool (bvult #b1111111111111111111110 autoname_2))
(define-fun $f12 () Bool (bvult autoname_3 (bvadd autoname_2 #b0000000000000000000001)))
(define-fun $f13 () Bool (and (not $f11) $f1 (not $f3) (not $f12)))
(define-fun $f14 () Bool (and (not $f2) $f1 (not $f11) (not $f12)))
(define-fun $f15 () Bool (and (not $f3) $f9))
(define-fun $f16 () Bool (= $f5 #b1))
(define-fun $f17 () Bool (and (= (bvadd $f6 autoname_3) #b0000000000000000000000) $f16))
(define-fun $f18 () Bool (and (= (bvadd (bvadd autoname_1 autoname_2) $f7) #b0000000000000000000000) $f16))
(define-fun .f11 () Bool (not (not (and (not (and $f8 $f4)) (not (and $f8 $f10)) (not (and $f8 $f13)) (not (and $f8 $f14)) (not (and $f8 $f15)) (not (and $f17 $f15)) (not (and $f18 $f4)) (not (and $f18 $f13)) (not (and $f17 $f10)) (not (and $f17 $f4)) (not (and $f18 $f14)) true))))

(assert (! .f11 :interpolation-group .g1))

(declare-fun next_autoname_1 () (_ BitVec 22))
(declare-fun next_autoname_2 () (_ BitVec 22))
(declare-fun next_autoname_3 () (_ BitVec 22))
(declare-fun next_autoname_4 () (_ BitVec 22))
(declare-fun next_autoname_5 () (_ BitVec 22))
(declare-fun next_autoname_6 () (_ BitVec 22))
(declare-fun next_autoname_7 () (_ BitVec 22))
(define-fun .f12 () Bool (bvult next_autoname_7 autoname_7))
(define-fun .f13 () Bool (bvult next_autoname_6 autoname_6))
(define-fun .f14 () Bool (bvult next_autoname_5 autoname_5))
(define-fun .f15 () Bool (bvult next_autoname_4 autoname_4))
(define-fun .f16 () Bool (bvult next_autoname_3 autoname_3))
(define-fun .f17 () Bool (bvult next_autoname_2 autoname_2))
(define-fun .f18 () Bool (bvult next_autoname_1 autoname_1))

(assert (! .f12 :interpolation-group .g1))
(assert (! .f13 :interpolation-group .g1))
(assert (! .f14 :interpolation-group .g1))
(assert (! .f15 :interpolation-group .g1))
(assert (! .f16 :interpolation-group .g1))
(assert (! .f17 :interpolation-group .g1))
(assert (! .f18 :interpolation-group .g1))

(check-sat)
(get-interpolant (.g0))
