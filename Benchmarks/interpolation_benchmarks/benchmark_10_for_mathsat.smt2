;; MathSAT API call trace
;; generated on Mon Oct 10 14:21:33 2016
(set-option :global-decls true)
(set-option :config "verbosity=0")
(set-option :config "proof_generation=true")
(set-option :config "interpolation=true")
(set-option :config "model_generation=true")
(set-option :config "bool_model_generation=false")
(set-option :config "unsat_core_generation=0")
(set-option :config "random_seed=91648253")
(set-option :config "debug.dump_theory_lemmas=false")
(set-option :config "debug.solver_enabled=true")
(set-option :config "printer.bv_number_format=0")
(set-option :config "printer.fp_number_format=1")
(set-option :config "printer.defines_prefix=")
(set-option :config "preprocessor.toplevel_propagation=false")
(set-option :config "preprocessor.toplevel_propagation_limit=0")
(set-option :config "preprocessor.simplification=1")
(set-option :config "preprocessor.ite_minimization=false")
(set-option :config "preprocessor.ite_minimization_call_limit=150000")
(set-option :config "preprocessor.interpolation_ite_elimination=true")
(set-option :config "preprocessor.partial_nnf_conversion=false")
(set-option :config "dpll.restart_strategy=0")
(set-option :config "dpll.restart_initial=200")
(set-option :config "dpll.restart_geometric_factor=1.5")
(set-option :config "dpll.store_tlemmas=false")
(set-option :config "dpll.branching_random_frequency=0")
(set-option :config "dpll.branching_initial_phase=0")
(set-option :config "dpll.branching_cache_phase=2")
(set-option :config "dpll.branching_random_invalidate_phase_cache=false")
(set-option :config "dpll.branching_random_ignore_polarity=true")
(set-option :config "dpll.ghost_filtering=true")
(set-option :config "dpll.minimize_model=false")
(set-option :config "dpll.allsat_minimize_model=false")
(set-option :config "dpll.allsat_allow_duplicates=false")
(set-option :config "dpll.pop_btpoint_reset_var_order=false")
(set-option :config "dpll.glucose_var_activity=false")
(set-option :config "dpll.glucose_learnt_minimization=false")
(set-option :config "dpll.interpolation_mode=0")
(set-option :config "dpll.proof_simplification=false")
(set-option :config "dpll.preprocessor.mode=0")
(set-option :config "dpll.preprocessor.clause_size_limit=20")
(set-option :config "dpll.preprocessor.subsumption_size_limit=1000")
(set-option :config "dpll.preprocessor.elimination_grow_limit=0")
(set-option :config "dpll.preprocessor.elimination_phase=1")
(set-option :config "dpll.preprocessor.elimination_recent_vars_only=false")
(set-option :config "dpll.preprocessor.try_reelimination=true")
(set-option :config "theory.eq_propagation=true")
(set-option :config "theory.interface_eq_policy=2")
(set-option :config "theory.pairwise_interface_eq=true")
(set-option :config "theory.pure_literal_filtering=false")
(set-option :config "theory.euf.enabled=true")
(set-option :config "theory.euf.dyn_ack=0")
(set-option :config "theory.euf.dyn_ack_threshold=1")
(set-option :config "theory.euf.dyn_ack_limit=1000")
(set-option :config "theory.la.enabled=true")
(set-option :config "theory.la.split_rat_eq=false")
(set-option :config "theory.la.delay_alien=false")
(set-option :config "theory.la.pivoting_greedy_threshold=0")
(set-option :config "theory.la.lazy_expl_threshold=10")
(set-option :config "theory.la.interpolation_laz_use_floor=true")
(set-option :config "theory.la.pure_equality_filtering=true")
(set-option :config "theory.la.detect_euf_fragment=false")
(set-option :config "theory.la.deduction_enabled=true")
(set-option :config "theory.la.laz_equality_elimination=true")
(set-option :config "theory.la.laz_internal_branch_and_bound=true")
(set-option :config "theory.la.laz_internal_branch_and_bound_limit=1")
(set-option :config "theory.la.laz_cuts_from_proofs_mode=3")
(set-option :config "theory.la.laz_enabled=true")
(set-option :config "theory.la.laz_unit_cube_test=true")
(set-option :config "theory.la.interpolation_mode=0")
(set-option :config "theory.bv.enabled=true")
(set-option :config "theory.bv.div_by_zero_mode=0")
(set-option :config "theory.bv.delay_propagated_eqs=true")
(set-option :config "theory.bv.eager=false")
(set-option :config "theory.bv.bit_blast_mode=0")
(set-option :config "theory.bv.interpolation_mode=0")
(set-option :config "theory.bv.proof_simplification=false")
(set-option :config "theory.bv.lazydpll.restart_strategy=0")
(set-option :config "theory.bv.lazydpll.restart_initial=200")
(set-option :config "theory.bv.lazydpll.restart_geometric_factor=1.5")
(set-option :config "theory.bv.lazydpll.branching_random_frequency=0")
(set-option :config "theory.bv.lazydpll.branching_initial_phase=0")
(set-option :config "theory.bv.lazydpll.branching_cache_phase=2")
(set-option :config "theory.bv.lazydpll.branching_random_invalidate_phase_cache=false")
(set-option :config "theory.bv.lazydpll.branching_random_ignore_polarity=true")
(set-option :config "theory.bv.lazydpll.ghost_filtering=false")
(set-option :config "theory.bv.lazydpll.glucose_var_activity=false")
(set-option :config "theory.bv.lazydpll.glucose_learnt_minimization=false")
(set-option :config "theory.arr.enabled=true")
(set-option :config "theory.arr.mode=0")
(set-option :config "theory.arr.lazy_lemmas=true")
(set-option :config "theory.arr.check_on_approx=false")
(set-option :config "theory.arr.auto_wr_lemma=true")
(set-option :config "theory.arr.enable_wr_lemmas=true")
(set-option :config "theory.arr.enable_row_lemmas=true")
(set-option :config "theory.arr.enable_ext_lemmas=true")
(set-option :config "theory.arr.max_wr_lemmas=0")
(set-option :config "theory.arr.max_row_lemmas=0")
(set-option :config "theory.arr.max_ext_lemmas=0")
(set-option :config "theory.arr.enable_ext_polarity=true")
(set-option :config "theory.arr.enable_ext_arg=true")
(set-option :config "theory.arr.enable_witness=false")
(set-option :config "theory.arr.enable_nonlinear=true")
(set-option :config "theory.arr.enable_nonlinear_strat=false")
(set-option :config "theory.arr.enable_foreign=false")
(set-option :config "theory.arr.permanent_lemma_inst=false")
(set-option :config "theory.fp.enabled=true")
(set-option :config "theory.fp.minmax_zero_mode=1")
(set-option :config "theory.fp.mode=1")
(set-option :config "theory.fp.bv_combination_enabled=true")
(set-option :config "theory.fp.bit_blast_mode=2")
(set-option :config "theory.fp.dpll.restart_strategy=3")
(set-option :config "theory.fp.dpll.restart_initial=200")
(set-option :config "theory.fp.dpll.restart_geometric_factor=1.5")
(set-option :config "theory.fp.dpll.branching_random_frequency=0.01")
(set-option :config "theory.fp.dpll.branching_initial_phase=0")
(set-option :config "theory.fp.dpll.branching_cache_phase=1")
(set-option :config "theory.fp.dpll.branching_random_invalidate_phase_cache=false")
(set-option :config "theory.fp.dpll.branching_random_ignore_polarity=true")
(set-option :config "theory.fp.dpll.ghost_filtering=false")
(set-option :config "theory.fp.dpll.glucose_var_activity=true")
(set-option :config "theory.fp.dpll.glucose_learnt_minimization=true")
(set-option :config "theory.fp.acdcl_conflict_generalization=2")
(set-option :config "theory.fp.interpolation_mode=0")
(set-option :config "theory.fp.acdcl_single_propagation_limit=0")
(set-option :config "theory.fp.acdcl_single_generalization_limit=0")
(set-option :config "theory.fp.acdcl_generalization_fair=true")

(reset-assertions)
(declare-fun CLK_1 () (_ BitVec 1))
(declare-fun CLK_2 () (_ BitVec 1))
(declare-fun CLK_3 () (_ BitVec 1))
(declare-fun CP_GRT_RP_1 () (_ BitVec 1))
(declare-fun CP_GRT_RP_0 () (_ BitVec 1))
(declare-fun CP_MINUS_RP_0 () (_ BitVec 16))
(declare-fun CP_SUB_RP_1 () (_ BitVec 16))
(declare-fun CP_SUB_RP_2 () (_ BitVec 16))
(declare-fun CP_SUB_RP_3 () (_ BitVec 16))
(declare-fun CRRNT_PWR_2 () (_ BitVec 16))
(declare-fun RESET_1 () (_ BitVec 1))
(declare-fun RESET_2 () (_ BitVec 1))
(declare-fun RESET_3 () (_ BitVec 1))
(declare-fun RFRNC_PWR_2 () (_ BitVec 16))
(declare-fun RP_GRT_CP_1 () (_ BitVec 1))
(declare-fun RP_GRT_CP_0 () (_ BitVec 1))
(declare-fun TIMER_1 () (_ BitVec 16))
(declare-fun TIMER_2 () (_ BitVec 16))
(define-fun $e1 () Bool (= CLK_1 CLK_2))
(define-fun $e2 () Bool (and (= RESET_1 RESET_2) (= CP_SUB_RP_1 CP_SUB_RP_2) $e1))
(define-fun $e3 () Bool (= RESET_1 #b1))
(define-fun $e4 () Bool (= CP_GRT_RP_0 #b0))
(define-fun $e5 () Bool (bvult CP_SUB_RP_1 #b0000011000000000))
(define-fun $e6 () Bool (and (= CLK_1 #b1) (not $e1)))
(define-fun $e7 () Bool (bvult #b0111111111111111 CP_SUB_RP_1))
(define-fun $e8 () Bool (= TIMER_1 #b1111111111111111))
(define-fun $e9 () Bool (= CP_GRT_RP_0 CP_GRT_RP_1))
(define-fun $e10 () Bool (= CLK_2 CLK_3))
(define-fun $e11 () Bool (= TIMER_1 #b0000000000000000))
(define-fun $e12 () Bool (bvult CP_SUB_RP_2 #b0000011000000000))
(define-fun $e13 () Bool (bvult #b0111111111111111 CP_SUB_RP_2))
(define-fun $e14 () Bool (= TIMER_1 TIMER_2))
(define-fun $e15 () Bool (ite (= TIMER_2 #b1111111111111111) $e14 (= TIMER_1 (bvadd TIMER_2 #b0000000000000001))))
(define-fun $e16 () Bool (= RP_GRT_CP_0 #b0))
(define-fun $e17 () Bool (= RP_GRT_CP_0 RP_GRT_CP_1))
(define-fun .f1 () Bool (ite (not (and (= RESET_2 RESET_3) (= CP_SUB_RP_2 CP_SUB_RP_3) $e10)) (ite (= RESET_2 #b1) $e11 (ite $e12 $e11 (ite (and (= CLK_2 #b1) (not $e10)) (ite (not $e12) (ite (not $e13) $e15 (ite $e13 $e15 $e14)) $e14) $e14))) $e14))
(define-fun .f2 () Bool (= CP_SUB_RP_1 (bvadd CRRNT_PWR_2 (bvmul #b1111111111111111 RFRNC_PWR_2))))
(define-fun .f3 () Bool (ite (not $e2) (ite $e3 $e4 (ite $e5 $e4 (ite $e6 (ite (not $e5) (ite (not $e7) (ite $e8 (= CP_GRT_RP_0 #b1) $e9) (ite $e7 (ite $e8 $e4 $e9) $e9)) $e9) $e9))) $e9))
(define-fun .f4 () Bool (= CP_MINUS_RP_0 CP_SUB_RP_1))
(define-fun .f5 () Bool (ite (not $e2) (ite $e3 $e16 (ite $e5 $e16 (ite $e6 (ite (not $e5) (ite (not $e7) (ite $e8 $e16 $e17) (ite $e7 (ite $e8 (= RP_GRT_CP_0 #b1) $e17) $e17)) $e17) $e17))) $e17))

(assert (! .f1 :interpolation-group .g0))
(assert (! .f2 :interpolation-group .g0))
(assert (! .f3 :interpolation-group .g0))
(assert (! .f4 :interpolation-group .g0))
(assert (! .f5 :interpolation-group .g0))

(define-fun $f1 () Bool (= (bvadd CLK_1 CLK_2) #b0))
(define-fun $f2 () Bool (= (bvadd CP_GRT_RP_0 CP_GRT_RP_1) #b0))
(define-fun $f3 () Bool (and $f2 $f1))
(define-fun $f4 () Bool (= (bvadd RESET_2 RESET_3) #b0))
(define-fun $f5 () Bool (= (bvadd CLK_2 CLK_3) #b0))
(define-fun $f6 () Bool (= (bvadd RP_GRT_CP_0 RP_GRT_CP_1) #b0))
(define-fun $f7 () Bool (and $f4 $f3 $f5 $f6))
(define-fun $f8 () Bool (= (bvadd RESET_1 RESET_2) #b0))
(define-fun $f9 () (_ BitVec 16) (bvmul #b1111111111111111 CRRNT_PWR_2))
(define-fun $f10 () (_ BitVec 16) (bvmul #b1111111111111111 CP_SUB_RP_3))
(define-fun $f11 () Bool (= CP_GRT_RP_0 #b0))
(define-fun $f12 () Bool (= RP_GRT_CP_0 #b0))
(define-fun $f13 () Bool (= RESET_1 #b1))
(define-fun $f14 () Bool (and $f4 $f11 $f5 $f12 (not $f13)))
(define-fun $f15 () Bool (= (bvadd (bvadd CP_MINUS_RP_0 $f9) RFRNC_PWR_2) #b0000000000000000))
(define-fun $f16 () (_ BitVec 16) (bvmul #b1111111111111111 RFRNC_PWR_2))
(define-fun $f17 () Bool (and (not (= (bvadd (bvadd $f10 CRRNT_PWR_2) $f16) #b0000000000000000)) $f15))
(define-fun $f18 () (_ BitVec 16) (bvadd CRRNT_PWR_2 $f16))
(define-fun $f19 () Bool (bvult #b0000010111111111 $f18))
(define-fun $f20 () Bool (and (not $f19) $f17))
(define-fun $f21 () Bool (= CLK_1 #b1))
(define-fun $f22 () Bool (and $f4 $f2 $f5 $f6 (not $f13) (not $f21)))
(define-fun $f23 () Bool (bvult $f18 #b0000011000000000))
(define-fun $f24 () Bool (and (not $f23) $f17))
(define-fun $f25 () Bool (and (not $f19) $f15))
(define-fun $f26 () Bool (and (= CP_GRT_RP_0 #b1) $f21))
(define-fun $f27 () Bool (and (not $f23) $f15))
(define-fun $f28 () Bool (and (not (bvult #b0111111111111111 $f18)) $f27))
(define-fun $f29 () Bool (and (not $f13) $f7))
(define-fun $f30 () Bool (= RESET_2 #b1))
(define-fun $f31 () Bool (and $f12 $f11 (not $f13) (not $f30)))
(define-fun $f32 () Bool (and $f6 $f3))
(define-fun $f33 () Bool (and (not $f30) $f32))
(define-fun $f34 () Bool (and (not $f13) $f32 (not $f30)))
(define-fun $f35 () Bool (and $f2 $f21))
(define-fun $f36 () Bool (and $f6 $f35 (not $f13) (not $f1) (not $f30)))
(define-fun $f37 () Bool (and (not $f5) $f36))
(define-fun $f38 () Bool (and $f6 $f2 (not $f13) (not $f21) (not $f1) (not $f30)))
(define-fun $f39 () Bool (and (not (bvult $f18 #b1000000000000000)) $f27))
(define-fun $f40 () Bool (and $f11 $f13))
(define-fun $f41 () Bool (and $f30 $f40 $f12))
(define-fun $f42 () Bool (and $f4 $f40 $f5 $f12))
(define-fun $f43 () Bool (and $f30 $f3 $f6))
(define-fun $f44 () Bool (and $f8 $f43))
(define-fun $f45 () Bool (and $f8 $f33))
(define-fun $f46 () Bool (and (not $f4) $f36))
(define-fun $f47 () Bool (and $f30 $f35 $f6 (not $f13) (not $f1)))
(define-fun $f48 () Bool (and (not $f4) $f47))
(define-fun $f49 () Bool (and $f30 $f11 $f12 (not $f13)))
(define-fun $f50 () Bool (and (not $f1) $f49))
(define-fun $f51 () Bool (and $f12 $f40))
(define-fun $f52 () Bool (and (not $f1) $f51 (not $f30)))
(define-fun $f53 () Bool (and $f30 $f2 $f6 (not $f13) (not $f21) (not $f1)))
(define-fun $f54 () Bool (and (not $f5) $f47))
(define-fun $f55 () Bool (and (not $f13) $f43))
(define-fun $f56 () Bool (and (not $f30) $f51))
(define-fun $f57 () Bool (and $f12 $f26 (not $f13) (not $f1) (not $f30)))
(define-fun $f58 () Bool (= CLK_2 #b1))
(define-fun $f59 () Bool (and $f21 $f11))
(define-fun $f60 () Bool (= RP_GRT_CP_0 #b1))
(define-fun $f61 () Bool (and $f60 $f59 (not $f13) (not $f1) (not $f30)))

(define-fun .f6 () Bool (not (not (and (not (and (= (bvadd CP_MINUS_RP_0 $f10) #b0000000000000000) (= (bvadd (bvadd CP_SUB_RP_3 $f9) RFRNC_PWR_2) #b0000000000000000) $f8 $f7)) (not (and $f20 $f14)) (not (and $f24 $f22)) (not (and (not $f1) $f14 $f25)) (not (and $f4 $f26 $f5 $f12 (not $f13) (not $f1) $f28)) (not (and $f24 $f29)) (not (and (not $f5) $f31 $f25)) (not (and (not $f5) $f33 $f8 $f25)) (not (and (not $f5) $f34 $f27)) (not (and $f28 $f37)) (not (and (not $f5) $f38 $f27)) (not (and $f39 $f37)) (not (and (not $f1) $f41 (not $f5) $f15)) (not (and (not $f1) $f42 $f15)) (not (and (not $f5) $f41 $f15)) (not (and $f17 $f42)) (not (and (not $f5) $f43 $f8 $f15)) (not (and (not $f4) $f41 $f15)) (not (and (not $f4) $f44 $f15)) (not (and (not $f4) $f45 $f25)) (not (and (not $f4) $f31 $f25)) (not (and (not $f4) $f34 $f27)) (not (and (not $f4) $f38 $f27)) (not (and $f28 $f46)) (not (and $f39 $f46)) (not (and $f28 $f48)) (not (and (not $f4) $f50 $f25)) (not (and (not $f4) $f52 $f15)) (not (and (not $f4) $f53 $f27)) (not (and (not $f5) $f52 $f15)) (not (and $f39 $f48)) (not (and $f28 $f54)) (not (and (not $f5) $f53 $f27)) (not (and $f39 $f54)) (not (and (not $f5) $f55 (not $f8) $f27)) (not (and (not $f4) $f55 (not $f8) $f27)) (not (and (not $f5) $f56 (not $f8) $f15)) (not (and (not $f4) $f56 (not $f8) $f15)) (not (and (not $f5) $f50 $f25)) (not (and (not $f8) $f14 $f25)) (not (and (not $f8) $f42 $f15)) (not (and (not $f5) $f49 (not $f8) $f25)) (not (and (not $f4) $f49 (not $f8) $f25)) (not (and $f15 $f41)) (not (and $f17 $f44)) (not (and $f28 $f36)) (not (and $f20 $f45)) (not (and $f28 $f47)) (not (and $f39 $f47)) (not (and $f25 $f31)) (not (and $f39 $f36)) (not (and (not $f5) $f57 (not $f58) $f28)) (not (and (not $f4) $f57 (not $f58) $f28)) (not (and (not $f8) $f29 $f27)) (not (and (not $f1) $f22 $f27)) (not (and $f4 $f59 $f5 $f60 (not $f13) (not $f1) $f39)) (not (and (not $f5) $f61 (not $f58) $f39)) (not (and (not $f4) $f61 (not $f58) $f39)) true))))

(assert (! .f6 :interpolation-group .g1))

(declare-fun next_CP_MINUS_RP_0 () (_ BitVec 16))
(declare-fun next_CP_SUB_RP_3 () (_ BitVec 16))
(declare-fun next_CRRNT_PWR_2 () (_ BitVec 16))
(define-fun .f7 () Bool (bvult next_CRRNT_PWR_2 CRRNT_PWR_2))
(define-fun .f8 () Bool (bvult next_CP_SUB_RP_3 CP_SUB_RP_3))
(define-fun .f9 () Bool (bvult next_CP_MINUS_RP_0 CP_MINUS_RP_0))

(assert (! .f7 :interpolation-group .g1))
(assert (! .f8 :interpolation-group .g1))
(assert (! .f9 :interpolation-group .g1))

(check-sat)
(get-interpolant (.g0))
